/**
 * @file: analytic-events.ts
 * @copyright: 2021, zhichetech co., ltd.
 *
 * Analytic events functions in this file are generated by a tool from the
 * definition at https://git.zhichetech.com/dev/analytics-events.
 * Don't make changes to this file, otherwise all changes you made will be
 * overwritten the next time this file is automatically generated again.
 */

/* eslint-disable @typescript-eslint/no-use-before-define */
/* eslint-disable @typescript-eslint/member-ordering */

export type AnalyticEventProps = {
  [key: string]: any;
  [index: number]: any;
};

export type AnalyticEventListener = (
  event: string,
  props?: AnalyticEventProps,
) => void;

export interface AnalyticEventEmitter {
  emit(event: string, props?: AnalyticEventProps): void;
  addEventListener(listener: AnalyticEventListener): () => void;
  removeEventListener(listener: AnalyticEventListener): void;
}

/**
 * Class that provides methods for psl analytic event tracking.
 * @abstract
 *
 * @description
 * This class is abstract thus is not intended be used directly by creating
 * instance of this class and call event tracking methods on it.
 *
 * Instead, either use the singleton instance `AnalyticEvents.default` that
 * provides the default implementation in a event driven manner, for example:
 *
 * @example
 * ```typescript
 * // register event listener that handles emitted events
 * AnalyticEvents.default.addEventListener((event, props) => {
 *  // call other event library method to do the real event dispatch
 *  someEventLib.track(event, props);
 * });
 * // call instance methods on the default instance to emit events
 * AnalyticEvents.default.liveShowBroadcastStarted({
 *   showId: '...',
 *   agoraAccount: '...'
 * });
 * ```
 * Or, you can implement this class yourself by implementing the `track` method,
 * for example,
 *
 * @example
 * ```typescript
 * class MyAnalyticEventsImpl extends AnalyticEvents {
 *   track(event: string, props: AnalyticEventProps) {
 *     // call other event library method to do the real event dispatch
 *     someEventLib.track(event, props);
 *   }
 * }
 * // create instance of your implementation
 * const analyticEvents = new MyAnalyticEventsImpl();
 * // and then call instance event tracking methods on it
 * analyticEvents.liveShowBroadcastStarted({
 *   showId: '...',
 *   agoraAccount: '...'
 * });
 * ```
 * The default implementation is recommended to use unless custom implementation
 * is necessary in rare cases.
 */
export abstract class AnalyticEvents {
  //#region Default Implementation
  /** @readonly instance that implements the default analytic event tracking */
  static readonly default = new (class DefaultAnalyticEventsImpl
    extends AnalyticEvents
    implements AnalyticEventEmitter
  {
    private readonly listeners: AnalyticEventListener[] = [];

    /**
     * Method that can be called to emit custom analytic event that is not
     * exposed via the automatically generated tracking methods.
     * @param event the name of the custom event to emit
     * @param [props] the custom event properties
     */
    emit(event: string, props?: AnalyticEventProps): void {
      props = eventPropsConverted(props);
      for (const listener of this.listeners) {
        listener(event, props);
      }
    }

    /**
     * Add analytic event listener and implement actual event forward there.
     * @param listener the event listener to add
     * @returns a function that can be called to remove the listener
     */
    addEventListener(listener: AnalyticEventListener): () => void {
      this.listeners.push(listener);
      return () => {
        this.removeEventListener(listener);
      };
    }

    /**
     * Remove the given event listener.
     * @param listener the listener to remove
     */
    removeEventListener(listener: AnalyticEventListener): void {
      const index = this.listeners.indexOf(listener);
      if (index >= 0) this.listeners.splice(index, 1);
    }

    // the default track method implementation
    protected track(event: string, props?: AnalyticEventProps) {
      this.emit(event, props);
    }
  })();
  //#endregion

  /**
   * Derived class should implement this method to track the given events
   * with properties.
   * @param {string} event - event name
   * @param {string} [props] - event properties
   */
  protected abstract track(event: string, props?: AnalyticEventProps): void;

  //#region Application-level Analytic Events

  /**
   * Analytic event logged on app launched
   * @param props - event properties
   * @param [extra] - extra properties for this event
   */
  appLaunched(
    props: {
      /** number of application launches */
      counter: number;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('app_launched', { ...props, ...extra });
  }

  /**
   * Analytic event logged on app installed
   * @param [extra] - extra properties for this event
   */
  appInstalled(extra?: AnalyticEventProps) {
    this.track('app_installed', extra);
  }

  //#endregion

  //#region General User Related Analytic Events

  /**
   * Analytic event logged on user profile updated
   * @param [extra] - extra properties for this event
   */
  userProfileUpdated(extra?: AnalyticEventProps) {
    this.track('user_profile_updated', extra);
  }

  /**
   * Analytic event logged on user avatar uploaded
   * @param [extra] - extra properties for this event
   */
  userAvatarUploaded(extra?: AnalyticEventProps) {
    this.track('user_avatar_uploaded', extra);
  }

  /**
   * Analytic event logged on user login started
   * @param props - event properties
   * @param [extra] - extra properties for this event
   */
  userLoginStarted(
    props: {
      /** login method the user has selected */
      loginMethod: string;
      /** the phone number with country code used for login */
      phone?: string | null;
      /** in which context the user logged in */
      scene?: string | null;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('user_login_started', { ...props, ...extra });
  }

  /**
   * Analytic event logged on user login success
   * @param props - event properties
   * @param [extra] - extra properties for this event
   */
  userLoginSuccess(
    props: {
      /** login method the user has selected */
      loginMethod: string;
      /** the phone number with country code used for login */
      phone?: string | null;
      /** in which context the user logged in */
      scene?: string | null;
      /** authentication user id of user that has logged in */
      userId: string;
      /** display/full name of the user that has logged in */
      displayName?: string | null;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('user_login_success', { ...props, ...extra });
  }

  /**
   * Analytic event logged on user login failed
   * @param props - event properties
   * @param [extra] - extra properties for this event
   */
  userLoginFailed(
    props: {
      /** login method the user has selected */
      loginMethod: string;
      /** the phone number with country code used for login */
      phone?: string | null;
      /** in which context the user logged in */
      scene?: string | null;
      /** the error detail about this login failure */
      detail: string;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('user_login_failed', { ...props, ...extra });
  }

  /**
   * Analytic event logged on user logout started
   * @param [extra] - extra properties for this event
   */
  userLogoutStarted(extra?: AnalyticEventProps) {
    this.track('user_logout_started', extra);
  }

  /**
   * Analytic event logged on user logout success
   * @param [props] - event properties
   * @param [extra] - extra properties for this event
   */
  userLogoutSuccess(
    props?: {
      /** user_id property */
      userId?: string | null;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('user_logout_success', { ...props, ...extra });
  }

  /**
   * Analytic event logged on user logout failed
   * @param props - event properties
   * @param [extra] - extra properties for this event
   */
  userLogoutFailed(
    props: {
      /** user_id property */
      userId?: string | null;
      /** detail property */
      detail: string;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('user_logout_failed', { ...props, ...extra });
  }

  //#endregion

  //#region Remote Push Notification Related Analytic Events

  /**
   * Remote Push Notification Related Analytic Events
   * @param [props] - event properties
   * @param [extra] - extra properties for this event
   */
  notification(
    props?: {
      /** type of this notification */
      type?: 'custom' | null;
    },
    extra?: AnalyticEventProps,
  ) {
    this.track('notification', { ...props, ...extra });
  }

  //#endregion
}

/**
 * Convert the given event props to the canonical form so that the property
 * keys all take the snake_cased form in order to keep them consistent with
 * their original definition in the schema configuration file.
 * @param [props] - the event props to convert
 * @returns converted props with canonical property keys
 */
export function eventPropsConverted(props: AnalyticEventProps | undefined) {
  if (!props) {
    return props;
  }
  const transformedProps: typeof props = {};
  for (const p in props) {
    const key = p
      .replace(
        /([^a-z])([a-z]*)/g,
        (_, l, t, i) =>
          (i ? '_' : '') + (l >= 'A' && l <= 'Z' ? l.toLowerCase() : l) + t,
      )
      .replace(/_{2,}/g, '_')
      .replace(/^_/, '')
      .replace(/_$/, '');
    transformedProps[key] = props[p];
  }
  return transformedProps;
}
